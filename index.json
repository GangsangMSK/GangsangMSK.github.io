[{"categories":["Swift 실습"],"content":"Swift Practice","date":"2022-10-18","objectID":"/221018/","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/18","uri":"/221018/"},{"categories":["Swift 실습"],"content":"Class (클래스) class Man{ var age : Int = 1 // Stored property var weight : Double = 3.5 } class Man{ var age : Int? var weight : Double? } class Man{ var age : Int? var weight : Double? func display(){ print(\"나이는 \\(age!), 몸무게는 \\(weight!)\") } } var MS : Man = Man() //클래스명 다음의 괄호는 눈에 보이지 않는 default initializer를 나타냄 MS.age = 23 MS.weight = 90 MS.display() (Type or Class) method 클래스명.클래스메서드() 타입 메서드 또는 클래스 메서드는 클래스 레벨에서 동작 타입 메서드는 인스턴스 메서드와 동일한 방법으로 선언하지만 class 나 static 키워드를 앞에 붙여서 선언 class키워드로 만든 클래스 메서드는 자식 클래스에서 override가능 함 class Man{ var age : Int = 1 var weight : Double = 3.5 func display(){ print(\"나이=\\(age), 몸무게=\\(weight)\") } class func cM(){ print(\"cM은 클래스 메서드입니다.\") } static func scM(){ print(\"scM은 클래스 메서드(static)\") } } var kim : Man = Man() kim.display() //인스턴스 메서드는 인스턴스가 호출 Man.cM() //클래스 메서드는 클래스가 호출 Man.scM() //클래스 메서드는 클래스가 호출 designated initializer class Man{ var age : Int var weight : Double func display(){ print(\"나이=\\(age), 몸무게=\\(weight)\") } init(age: Int, weight : Double){ self.age = age // self.age는 프로퍼티 age를 접근 self.weight = weight } //designated initializer } //init()을 하나라도 직접 만들면 default initializer는 사라짐 var kim : Man = Man(age:10, weight:20.5) kim.display() 클래스, 구조체, 열거형(enum) 인스턴스가 생성되는 시점에서 해야 할 초기화 작업 인스턴스가 만들어지면서 자동 호출됨 모든 프로퍼티(age, weight)를 다 초기화시키는 생성자 init()을 하나라도 직접 만들면 기본적으로 만들어지는 눈에 안보이는 default initializer는 사라짐 소멸자 인스턴스가 사라질 때 자동 호출 deinit{} ","date":"2022-10-18","objectID":"/221018/:0:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/18","uri":"/221018/"},{"categories":["Swift 실습"],"content":"Swift Practice","date":"2022-10-11","objectID":"/221011/","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/11","uri":"/221011/"},{"categories":["Swift 실습"],"content":"Function (함수) func add(first x: Int, second y: Int) -\u003e Int { // first, second : argument label // x, y : parameter name print(#function) //add(first:second:) return(x+y) } let a = add(first:10, second:20) //add(first:second:) func add(_ x: Int, _ y: Int) -\u003e Int { print(#function) //add(first:second:) return(x+y) } let a = add(10, 20) //add(_:_:) //Swift 2, 지금은 오류 var myValue = 10 func doubleValue (inout value: Int) -\u003e Int { value += value return(value) } doubleValue(value:\u0026myValue) //Swift 3이후 var myValue = 10 func doubleValue (value: inout Int) -\u003e Int { // Swift 에서 call by reference를 구현하는 방법 inout 사용 value += value return(value) } print(myValue) print(doubleValue(value : \u0026myValue)) // 매개변수에 \u0026 사용 print(myValue) func printName(firstName:String, lastName:String?){ // if let if let lName = lastName { // lastName이 nil이 아니면 print(lName,firstName) } else { print(\"성이 없네요!\") } // guard let guard let lName = lastName else { // lastName이 nil이면 print(\"성이 없네요!\") return // early exit, nil 일경우 return을 만나서 종료된다. } print(lName,firstName) // gurad let 바깥쪽의 구문에서도 내부 매개변수를 사용할 수 있다. } printName(firstName: \"길동\", lastName:\"홍\") // 길동 홍 printName(firstName: \"길동\", lastName:nil) // 성이 없네요! func multiplyByTen(value: Int?) { guard let number = value, number \u003c 10 else {//조건식(값이 있고 10보다 작은)이 거짓일 때 실행 print(\"수가 없거나 10보다 크다.\") //거짓 : 값이 없거나 10보다 크면 return } print(number*10) //조건식이 참일 때 실행, 주의 : number를 여기서도 사용 가능 } multiplyByTen(value: 3) //30 multiplyByTen(value: nil) multiplyByTen(value: 20) import Foundation let weight = 60.0 let height = 170.0 let bmi = weight / (height*height*0.0001) // kg/m*m var body = \"\" if bmi \u003e= 40 { body = \"3단계 비만\" } else if bmi \u003e= 30 \u0026\u0026 bmi \u003c 40 { body = \"2단계 비만\" } else if bmi \u003e= 25 \u0026\u0026 bmi \u003c 30 { body = \"1단계 비만\" } else if bmi \u003e= 18.5 \u0026\u0026 bmi \u003c 25 { body = \"정상\" } else { body = \"저체중\" } print(\"BMI:\",String(format:\"%.1f\",bmi), \"판정:\\(body)\") // String 사용을 위해 Foundation 를 import 해줘야 한다. BMI 측정 함수화 #1 리턴 후 출력 import Foundation func calcBMI(weight : Double, height : Double) -\u003e String{ let bmi = weight / (height*height*0.0001) // kg/m*m let shortenedBmi = String(format: \"%.1f\", bmi) var body = \"\" if bmi \u003e= 40{ body = \"3단계 비만\" } else if bmi \u003e= 30 \u0026\u0026 bmi \u003c 40 { body = \"2단계 비만\" } else if bmi \u003e= 25 \u0026\u0026 bmi \u003c 30 { body = \"1단계 비만\" } else if bmi \u003e= 18.5 \u0026\u0026 bmi \u003c 25 { body = \"정상\" } else { body = \"저체중\" } return \"BMI:\\(shortenedBmi), 판정:\\(body)\" } print(calcBMI(weight:62.5, height: 172.3)) // BMI:21.1, 판정:정상 #2 리턴 x import Foundation func calcBMI(weight : Double, height : Double) { let bmi = weight / (height*height*0.0001) // kg/m*m let shortenedBmi = String(format: \"%.1f\", bmi) var body = \"\" if bmi \u003e= 40{ body = \"3단계 비만\" } else if bmi \u003e= 30 \u0026\u0026 bmi \u003c 40 { body = \"2단계 비만\" } else if bmi \u003e= 25 \u0026\u0026 bmi \u003c 30 { body = \"1단계 비만\" } else if bmi \u003e= 18.5 \u0026\u0026 bmi \u003c 25 { body = \"정상\" } else { body = \"저체중\" } print(\"BMI:\\(shortenedBmi), 판정:\\(body)\") } calcBMI(weight:62.5, height: 172.3) #3 switch case 문 이용 import Foundation func calcBMI (weight : Double, height : Double) { //Void형 let bmi = weight / (height*height*0.0001) // kg/m*m let shortenedBmi = String(format: \"%.1f\", bmi) switch bmi { case 0.0..\u003c18.5: print(\"BMI:\\(shortenedBmi),판정:저체중\") case 18.5..\u003c25.0 : print(\"BMI:\\(shortenedBmi),판정:정상\") case 25.0..\u003c30.0 : print(\"BMI:\\(shortenedBmi),판정:1단계 비만\") case 30.0..\u003c40.0 : print(\"BMI:\\(shortenedBmi),판정:2단계 비만\") default : print(\"BMI:\\(shortenedBmi),판정:3단계 비만\") } } calcBMI(weight:62.5, height: 172.3) first class object swift의 함수는 1급 객체이다. 1급 객체(first class object) 또는 1급 시민(first class citizen) 다음 조건을 충족하는 객체를 1급 객체라고 한다. 변수에 저장할 수 있다. func up(num: Int) -\u003e Int { return num + 1 } func down(num: Int) -\u003e Int { return num - 1 } let toUp = up print(up(num:10)) print(toUp(10)) let toDown = down print(down(num:10)) print(toDown(10)) 매개변수로 전달할 수 있다. func upDown(Fun: (Int) -\u003e Int, value: Int) { let result = Fun(value) print(\"결과 = \\(result)\") } upDown(Fun:toUp, value: 10) //toUp(10) upDown(Fun:toDown, value: 10) //toDown(10) 리턴값으로 사용할 수 있다. func decideFun(x: Bool) -\u003e (Int) -\u003e Int { ","date":"2022-10-11","objectID":"/221011/:0:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/11","uri":"/221011/"},{"categories":["Swift 실습"],"content":"Swift Practice","date":"2022-10-04","objectID":"/221004/","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/04","uri":"/221004/"},{"categories":["Swift 실습"],"content":"if문 var x = 1 while true { if x \u003e 5 { break } //조건(x\u003e5)이 참일 때 실행(break) print(x) //1 2 3 4 5 x = x + 1 } guard else문 var x = 1 while true { guard x \u003c 10 else { break }//조건(x\u003c10)이 거짓일 때 실행(break) print(x) //1 2 3 4 5 6 7 8 9, 조건(x\u003c10)이 참일 때 실행 x = x + 1 } if문은 조건 다음에 있는 구문이 참일 때 실행되지만, guard문은 조검 다음에 있는 구문이 거짓일 떄 실행된다. switch case문 var value = 7 switch value { case 0: print(\"영\") case 1: print(\"일\") case 2: print(\"이\") case 3: print(\"삼\") default: print(\"4이상\") } // 4이상 let anotherCharacter: Character = \"a\" switch anotherCharacter { case \"a\": // Invalid, the case has an empty body case \"A\": print(\"The letter A\") default: print(\"Not the letter A\") } //error: 'case' label in a 'switch' should have at least one executable statement case별로 반드시 실행 가능한 구문이 있어야 한다. var value = 9 var days : Int = 0 switch(value) { case 1,3,5,7,8,10,12: print(\"31 일입니다\") case 4,6,9,11: print(\"30 일입니다\") case 2: print(\"28 or 29 일입니다\") default: print(\"월을 잘못 입력하셨습니다\") } //30 일입니다 var temperature = 60 switch (temperature) { case 0...49 where temperature % 2 == 0: print(\"Cold and even\") case 50...79 where temperature % 2 == 0: print(\"Warm and even\") case 80...110 where temperature % 2 == 0: print(\"Hot and even\") default: print(\"Temperature out of range or odd\") } //warn and enven var numbers: [Int] = [1, 2, 3, 4, 5] for num in numbers where num \u003c 2 { print(num) } // 1 where문을 통해 부가적인 조건을 제공한다. let weight = 100.0 let height = 170.0 let bmi = weight / (height*height*0.0001) // kg/m*m var body = \"\" switch bmi { case 40...: body = \"3단계 비만\" case 30...: body = \"2단계 비만\" case 25...: body = \"1단계 비만\" case 18.5...: body = \"정상\" default: body = \"저체중\" } print(\"BMI:\\(bmi), 판정:\\(body)\") //BMI:34.602076124567475, 판정:2단계 비만 fallthrough문 var value = 2 switch (value) { case 4: print(\"4\") fallthrough case 3: print(\"3\") fallthrough case 2: print(\"2\") fallthrough default: print(\"1\") } // 4 3 2 1 fallthrough를 사용하면 조건에 상관없이 통과하여 케이스 안에 있는 구문을 실행한다. 함수 parameter 함수를 정의할 떄 받는 인자 값을 넘겨 받는 매개변수 형식 매개변수(formal parameter) argument 함소를 호출할 때 주는 인수 값을 넘겨 주는 매개변수 실 매개변수(actual parameter) 함수를 Swift Class 내에서 선언하면 메서드(method)라고 한다. func sayHelloWorld() -\u003e Void { //리턴 값이 없을 경우 (-\u003e Void) 생략가능 print(\"Hello World!\") } sayHelloWorld() //호출 //Hello World! func add(x: Int, y: Int) -\u003e Int { return x + y } print(type(of:add)) //(Int, Int) -\u003e Int print(add(x: 5, y: 10)) // 15 let output = add(x: 10, y: 20) print(output) // 30 Swift에서 자료형은 () -\u003e () 으로 쓰는 것이 기본이다. 스위프트에서 함수를 만드는 4가지 방법은 다음과 같다. func add(first x: Int, second y: Int) -\u003e Int { // argument label return x + y } print(add(first: 5, second: 10)) // argument label 이 있을 경우 label명으로 argument를 줘야한다. // 15 // 함수명 : add(first:second:) func add(x: Int, y: Int) -\u003e Int { // overloading 사용 시 //외부 매개변수명(argument label)을 생략하면 내부 매개변수명이 외부 매개변수명까지 겸한다. return x + y } print(add(x: 3, y: 5)) // 8 // 함수명 : add(x:y:) func add(_ x: Int, _ y: Int) -\u003e Int { return x + y } print(add(5, 10)) // 함수명 : add(_:_:) func add(_ x: Int, with y: Int) -\u003e Int { // 이 경우를 가장 많이 사용한다. return x + y } print(add(5, with: 10)) // 함수명 : add(_:with:) func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u003e Int //자료형: (UITableView, Int) -\u003e Int //함수명: tableView(_:numberOfRowsInSection:) func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u003e UITableViewCell // (UITableView, IndexPath) -\u003e UITableViewCell // tableView(_:cellForRowAt:) func print( _ items: Any..., separator: String = \" \", terminator: String = \"\\n\" //default argument, 전달받은 값이 없을 경우 디폴트 값을 사용 ) func converter(length: Float) -\u003e (yards: Float, centimeters: Float, meters: Float) { // 인자 값을 튜플로 주기 let yards = length * 0.0277778 let centimeters = length * 2.54 let meters = length * 0.0254 return (yards, centimeters, meters) // ()생략 불가 } var lengthTuple = converter(length:30.8) print(lengthTuple) //(yards: 0.85555625, centimeters: 78.231995, meters: 0.78231996) print(lengthTuple.yards) //0.85555625 print(lengthTuple.centimeters) //78.231995 print(lengthTuple.meters) //0.78231996 func sss(x : In","date":"2022-10-04","objectID":"/221004/:0:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/10/04","uri":"/221004/"},{"categories":["Swift 문법"],"content":"Swift's Control Flow(if, for, for-in, switch, while etc","date":"2022-09-28","objectID":"/controlflow/","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"For-In Loops (For-In문) for-in 반복문은 컬렉션 또는 숫자 범위 내에 있는 목록을 반복한다. for 상수명 in 컬렉션 또는 범위 { // 실행될 코드 } ‘상수명’은 반복문이 돌면서 컬렉션 또는 범위에서 가져온 항목을 담게 될 상수이다. ‘컬렉션 또는 범위’는 반복문이 반복되면서 현재의 항목을 참조한다. 문자열 값들의 배열이거나 범위 연산, 문자들로 구성된 문자열일 수 있다. for index in 1...5 { print(index) } // index라는 이름의 상수에 현재 항목이 할당되면서 시작 // 1 2 3 4 5 for _ in 1...5 { print(\"Hello\") // _로 참조체 생략 가능 } // Hello Hello Hello Hello Hello // 배열의 요소 접근 let names = [\"A\", \"B\", \"C\", \"D\"] for name in names { print(name) } // A B C D let numberOfLegs = [\"Spider\": 8, \"Ant\": 6, \"Dog\": 4] //dictionary는 key:value형식의 배열 for (animalName, legCount) in numberOfLegs { print(\"\\(animalName)s have \\(legCount) legs\") } // Spiders have 8 legs // Ants have 6 legs // Dogs have 4 legs //dictionary에는 순서가 없어, 출력되는 순서는 매번 다를 수 있다. 아래와 같은 C 스타일의 for문은 Swift 3에서 없어졌다. for 초기화; 조건식; 증감식 { // 실행될 구문 } for var i = 0; i \u003c 10; i+=1 { // for i in 0..\u003c10 로 수정해야 함 print(i) } //error: C-style for statement has been removed in Swift 3 ","date":"2022-09-28","objectID":"/controlflow/:1:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"While Loops (While문) for 반복문은 몇 번 정도 반복해야 할지를 이미 아는 경우에 사용하기 적합하다. 어떠한 조건이 되기 전에 대체 몇 번 정도 반복해야 할지를 알 수는 없지만 그 조건을 만족할 때까지는 반복해야 하는 경우 while 반복문 사용한다. 지정된 조건을 만족할 때까지 작업을 반복한다. while 조건식 { // 구문 } var myCount = 0 while myCount \u003c 1000 { myCount+=1 } print(myCount) // myCount 변수가 1000보다 크지 않을 때까지 반복, 1000이 되는 시점에 반복문이 종료된다. ","date":"2022-09-28","objectID":"/controlflow/:2:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Repeat-While 다른 언어의 do-while문과 유사한 반복문이다. repeat { // 구문 } while 조건식 While문과는 다르게 최소 한번이상 구문을 실행하고, 조건이 거짓일 때까지 반복한다. var i = 10 repeat { i=i-1 print(i) //출력 결과 } while (i \u003e 0) ","date":"2022-09-28","objectID":"/controlflow/:3:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Conditonal Statements (조건적 구문) Swift에서는 두가지 조건문을 제공한다. ","date":"2022-09-28","objectID":"/controlflow/:4:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"IF 다른 프로그래밍 언어들과는 다르게, Swift에서는 if 문 다음의 실행 코드가 한 줄이라도 중괄호({})를 필수적으로 사용해야 한다. 기본적으로 ‘Boolean 표현식’이 참(true)으로 판단되면 중괄호로 감싸인 코드 실행되고 거짓(false)이면 중괄호로 감싸인 코드는 건너뛴다. 사용법으로는 아래와 같다. if만 사용한 경우 if Boolean 표현식 { // Boolean 표현식이 참일 경우 수행될 구문 } if, else를 사용한 경우 if Boolean 표현식 { // 표현식이 참일 경우 실행되는 구문 } else { // 표현식이 거짓일 경우 실행되는 구문 } if, else if, else를 사용한 경우 if Boolean 표현식 { // 표현식이 참일 경우 실행되는 구문 } else if Boolean 표현식 { // 선행되는 표현식이 거짓일 경우, 표현식이 참일 경우 실행되는 구문 } else { // 표현식이 거짓일 경우 실행되는 구문 } if, else if를 사용한 경우 if Boolean 표현식 { // 표현식이 참일 경우 실행되는 구문 } else if Boolean 표현식 { // 선행되는 표현식이 거짓일 경우, 표현식이 참일 경우 실행되는 구문 } ","date":"2022-09-28","objectID":"/controlflow/:4:1","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Switch Swift에서의 Switch문의 기본 사용방법이다. switch (some value to consider) { case (value 1): (respond to value 1) case (value 2), (value 3): (respond to value 2 or 3) default: (otherwise, do something else) } let someCharacter: Character = \"z\" switch someCharacter { case \"a\": print(\"The first letter of the alphabet\") case \"z\": print(\"The last letter of the alphabet\") default: print(\"Some other character\") } // Prints \"The last letter of the alphabet\" } ","date":"2022-09-28","objectID":"/controlflow/:4:2","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"No Implicit Fallthrough C/C++, Objective-C와 달리 case문 다음에 break 문을 포함할 필요가 없다. Swift는 일치하는 case문을 만나면 자동으로 빠져나온다. case별로 빠져 나가지 않고 아래로 계속 내려가게 하려면 fallthrough 문을 사용할 수 있다. case 안에는 최소 하나 이상의 구문이 존재 해야한다. 존재하지 않을 경우, 아래와 같이 오류가 발생한다. let anotherCharacter: Character = \"a\" switch anotherCharacter { case \"a\": // Invalid, case문에 body가 없으므로 에러가 발생한다. case \"A\": print(\"The letter A\") default: print(\"Not the letter A\") } // 컴파일 에러 발생! case 안에 콤마(,)로 구분해서 복수의 case 조건을 혼합(compound Cases)해 사용할 수 있습니다. let anotherCharacter: Character = \"a\" switch anotherCharacter { case \"a\", \"A\": print(\"The letter A\") default: print(\"Not the letter A\") } // Prints \"The letter A\" ","date":"2022-09-28","objectID":"/controlflow/:4:3","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Interval Matching switch문에서 case에 숫자의 특정 범위를 조건으로 사용할 수 있다. let approximateCount = 62 let countedThings = \"moons orbiting Saturn\" let naturalCount: String switch approximateCount { case 0: naturalCount = \"no\" case 1..\u003c5: naturalCount = \"a few\" case 5..\u003c12: naturalCount = \"several\" case 12..\u003c100: naturalCount = \"dozens of\" case 100..\u003c1000: naturalCount = \"hundreds of\" default: naturalCount = \"many\" } print(\"There are \\(naturalCount) \\(countedThings).\") // Prints \"There are dozens of moons orbiting Saturn.\" ","date":"2022-09-28","objectID":"/controlflow/:4:4","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Tuples 튜플을 사용하여 동일한 switch문에서 여러 값을 테스트할 수 있다. 튜플의 각 요소는 다른 값이나 범위연산자, 밑줄 문자(_)를 조건으로 사용할 수 있다. let somePoint = (1, 1) switch somePoint { case (0, 0): print(\"\\(somePoint) is at the origin\") case (_, 0): print(\"\\(somePoint) is on the x-axis\") case (0, _): print(\"\\(somePoint) is on the y-axis\") case (-2...2, -2...2): print(\"\\(somePoint) is inside the box\") default: print(\"\\(somePoint) is outside of the box\") } // Prints \"(1, 1) is inside the box\" ","date":"2022-09-28","objectID":"/controlflow/:4:5","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Value Bindings switch문에서 각각의 case문에 임시적으로 상수 또는 변수와 일치하는 값을 선언할 수 있다. 값이 case 본문 내의 임시 상수 또는 변수에 바인딩되기 때문에 값 바인딩이라고 한다. let anotherPoint = (2, 0) switch anotherPoint { case (let x, 0): print(\"on the x-axis with an x value of \\(x)\") case (0, let y): print(\"on the y-axis with a y value of \\(y)\") case let (x, y): print(\"somewhere else at (\\(x), \\(y))\") } // Prints \"on the x-axis with an x value of 2\" ","date":"2022-09-28","objectID":"/controlflow/:4:6","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Where switch, if 조건문에서 where를 사용하여 조건을 추가할 수 있다. let yetAnotherPoint = (1, -1) switch yetAnotherPoint { case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\") case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\") case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\") } // Prints \"(1, -1) is on the line x == -y\" var numbers: [Int] = [1, 2, 3, 4, 5] for num in numbers where num \u003e 3 { print(num) } // 4 5 ","date":"2022-09-28","objectID":"/controlflow/:4:7","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Compound Cases 동일한 본문을 공유하는 여러 case는 각 조건 사이에 쉼표(,)로 결합하여 사용할 수 있다. 조건이 길 경우, 개행할 수 있다. let someCharacter: Character = \"e\" switch someCharacter { case \"a\", \"e\", \"i\", \"o\", \"u\": print(\"\\(someCharacter) is a vowel\") case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\": print(\"\\(someCharacter) is a consonant\") default: print(\"\\(someCharacter) isn't a vowel or a consonant\") } // Prints \"e is a vowel\" Compound Cases 에서도 Value Bindings을 할 수 있다. let stillAnotherPoint = (9, 0) switch stillAnotherPoint { case (let distance, 0), (0, let distance): print(\"On an axis, \\(distance) from the origin\") default: print(\"Not on an axis\") } // Prints \"On an axis, 9 from the origin\" ","date":"2022-09-28","objectID":"/controlflow/:4:8","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Control Transfer Statements (제어 전송문) 제어 전송문은 한 코드에서 다른 코드로 제어를 전송하여 코드가 실행되는 순서를 변경한다. Swift에는 다음과 같은 5가지의 제어 전송문을 사용한다. continue break fallthrough return throw ","date":"2022-09-28","objectID":"/controlflow/:5:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Countinue continue문은 현재 loop를 중단하고 다음 loop를 수행하게 만든다. let puzzleInput = \"great minds think alike\" var puzzleOutput = \"\" let charactersToRemove: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \" \"] for character in puzzleInput { if charactersToRemove.contains(character) { continue } puzzleOutput.append(character) } print(puzzleOutput) // Prints \"grtmndsthnklk\" ","date":"2022-09-28","objectID":"/controlflow/:5:1","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Break Break문은 전체 제어 흐름문의 실행을 즉시 종료합니다. Break문은 스위치 또는 루프 문의 실행을 종료하려는 경우, 스위치 또는 루프 문 내부에서 사용한다. Break in a Loop Statement let puzzleInput = \"great minds think alike\" var puzzleOutput = \"\" let charactersToRemove: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \" \"] for character in puzzleInput { if charactersToRemove.contains(character) { break } puzzleOutput.append(character) } print(puzzleOutput) // Prints \"gr\" Break in a Switch Statement let numberSymbol: Character = \"三\" // Chinese symbol for the number 3 var possibleIntegerValue: Int? switch numberSymbol { case \"1\", \"١\", \"一\", \"๑\": possibleIntegerValue = 1 case \"2\", \"٢\", \"二\", \"๒\": possibleIntegerValue = 2 case \"3\", \"٣\", \"三\", \"๓\": possibleIntegerValue = 3 case \"4\", \"٤\", \"四\", \"๔\": possibleIntegerValue = 4 default: break } if let integerValue = possibleIntegerValue { print(\"The integer value of \\(numberSymbol) is \\(integerValue).\") } else { print(\"An integer value couldn't be found for \\(numberSymbol).\") } // Prints \"The integer value of 三 is 3.\" ","date":"2022-09-28","objectID":"/controlflow/:5:2","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Fallthrough C/C++, Objective-C와 달리 break문을 사용하지 않고 조건이 충족되면 자동으로 break된다. fallthrough 를 사용하면 이 자동으로 break가 사용되는 것을 막는 효과가 있다. let integerToDescribe = 5 var description = \"The number \\(integerToDescribe) is\" switch integerToDescribe { case 2, 3, 5, 7, 11, 13, 17, 19: description += \" a prime number, and also\" fallthrough default: description += \" an integer.\" } print(description) // Prints \"The number 5 is a prime number, and also an integer.\" ","date":"2022-09-28","objectID":"/controlflow/:5:3","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Labeled Statements 아래와 같은 형태로 label 이름과 while 조건을 넣어 특정 구문을 실행하는 구문으로 사용한다. (label name): while (condition) { (statements) } switch 문과 함께 다음과 같이 사용할 수 있다. gameLoop: while square != finalSquare { diceRoll += 1 if diceRoll == 7 { diceRoll = 1 } switch square + diceRoll { case finalSquare: // diceRoll will move us to the final square, so the game is over break gameLoop case let newSquare where newSquare \u003e finalSquare: // diceRoll will move us beyond the final square, so roll again continue gameLoop default: // this is a valid move, so find out its effect square += diceRoll square += board[square] } } print(\"Game over!\") ","date":"2022-09-28","objectID":"/controlflow/:5:4","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Early Exit guard문은 swift 2에 도입된 구문이다. guard문은 표현식이 거짓(false)으로 판단될 경우에 수행될 else 절을 반드시 포함해야 한다. else 절에 속한 코드는 제어 흐름문(return, break, continue, throw 구문)을 반드시 포함해야 함 guard문을 이용해 특정 조건을 만족하지 않으면 다음 코드를 실행하지 않도록 방어코드를 작성할 수 있다. func greet(person: [String: String]) { guard let name = person[\"name\"] else { return } print(\"Hello \\(name)!\") guard let location = person[\"location\"] else { print(\"I hope the weather is nice near you.\") return } print(\"I hope the weather is nice in \\(location).\") } greet(person: [\"name\": \"John\"]) // Prints \"Hello John!\" // Prints \"I hope the weather is nice near you.\" greet(person: [\"name\": \"Jane\", \"location\": \"Cupertino\"]) // Prints \"Hello Jane!\" // Prints \"I hope the weather is nice in Cupertino.\" ","date":"2022-09-28","objectID":"/controlflow/:6:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"참고자료 iOS 1주차-9 : 제어문(for-in, while, repeat~while, break, continue, if, guard, switch, where, fallthrough) The Swift Programming Language - ControlFlow The Swift Programming Language(한국어) - 제어문(ControlFlow) ","date":"2022-09-28","objectID":"/controlflow/:7:0","tags":["Swift"],"title":"[Swift] ControlFlow(제어문)","uri":"/controlflow/"},{"categories":["Swift 문법"],"content":"Swift's Operator","date":"2022-09-27","objectID":"/operator/","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Assingnment Operator (기본 할당 연산자) 할당 연산자는 두 개의 피연산자를 가진다. 왼쪽에 있는 피연산자는 값이 할당되는 변수 또는 상수이며, 오른쪽에 있는 피연산자는 할당할 값을 쓴다. 오른쪽 피연산자는 주로 산술식 또는 논리식을 수행하는 표현식이며, 그 결과는 왼쪽 피연산자인 변수나 상수에 할당한다. let a = 10 var b = 20 b = a // b에 10이 들어간다. let (x, y) = (1, 2) // x는 1이고, y는 2이다. ","date":"2022-09-27","objectID":"/operator/:1:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Arithmetic Operators (산술 연산자) 보통 두 개의 피연산자를 받는 이항(binary) 연산자이다. * 곱셈 / 나눗셈 + 덧셈 - 뺄셈 % 나머지 연산 x = y * 10 + z - 5 / 4 // 하나의 표현식 안에 여러 개의 연산자를 사용할 수 있음 예외에는 값이 음수임을 가리키는 단항 마이너스 연산자(unary negative operator)인 ‘ - ’ 가 있다. var x = -10 // 변수 x에 -10을 할당하기 위해 사용되는 단항 - 연산자 // - (단항) 변수 또는 표현식의 값을 음수로 만듦 ","date":"2022-09-27","objectID":"/operator/:2:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Compound Assignment Operators (복합 할당 연산자) C와 마찬가지로, Swift는 할당(=)을 다른 작업과 결합하는 복합 할당 연산자를 제공한다. x += y // == x = x + y x += y라는 표현은 a = a + 2의 축약한 것이다. 추가와 할당은 두 작업을 동시에 수행하는 하나의 연산자로 결합할 수 있다. x += y x와 y를 더하고 그 결과를 x에 할당 x -= y x에서 y를 빼고 그 결과를 x에 할당 x *= y x와 y를 곱하고 그 결과를 x에 할당 x /= y x를 y로 나누고 그 결과를 x에 할당 x %= y x를 y로 나눈 나머지를 x에 할당 x \u0026= y x와 y의 bit AND 연산 결과를 x에 할당 x |= y x와 y의 bit OR 연산 결과를 x에 할당 ","date":"2022-09-27","objectID":"/operator/:3:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Increment \u0026 Decrement Operator (증가 \u0026 감소 연산자) // 다음과 같이 사용한다. x = x + 1 // x 변수의 값을 1 증가시킴 x = x - 1 // x 변수의 값을 1 감소시킴 // C에서 사용되는 ++, -- 연산자는 Swift 3에서 없어졌다. x++ // Cannot find operator '++' in scope; did you mean '+= 1'? x-- // Cannot find operator '--' in scope; did you mean '-= 1'? //라는 오류가 난다. ","date":"2022-09-27","objectID":"/operator/:3:1","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Comparison Operators (비교 연산자) 비교의 결과 값으로 Boolean 값을 반환한다. var result: Bool? var x = 10 var y = 20 result = x \u003c y //true x == y x와 y가 같다면 true를 반환 x \u003e y x가 y보다 크면 true를 반환 x \u003e= y x가 y보다 크거나 같다면 true를 반환 x \u003c y x가 y보다 작다면 true를 반환 x \u003c= y x가 y보다 작거나 같다면 true를 반환 x != y x와 y가 같지 않다면 true를 반환 ","date":"2022-09-27","objectID":"/operator/:4:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Ternary Conditional Operator (삼항 연산자) 비교 연산을 빠르게 하기 위해 삼항 연산자를 지원한다. [조건] ? [참 표현식] : [거짓 표현식] 삼항 연산자는 [조건] 부분을 계산하여 참(true) 혹은 거짓(false)을 확인하여 결과가 참이면 [참 표현식] 부분이 실행되며, 거짓이면 [거짓 표현식] 부분을 수행한다. if question { answer1 } else { answer2 } //삼항 연산자로의 변환 question ? answer1 : answer2 ","date":"2022-09-27","objectID":"/operator/:5:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Nil-Coalescing Operator (닐 병합 연산자) 옵셔널변수 ?? nil일 때 할당되는 값이다. 옵셔널 변수의 값이 nil이면 ?? 다음 값으로 할당된다. 옵셔널 변수의 값이 nil이 아니면 언래핑된 값이 나온다. let defaultColor = \"black\" var userDefinedColor: String? // defaults to nil var myColor = userDefinedColor ?? defaultColor // nil이므로 defaultColor인 black으로 할당됨 print(myColor) // black userDefinedColor = \"red\" myColor = userDefinedColor ?? defaultColor //nil이 아니므로 언래핑된 red가 할당됨 print(myColor) // red // 중요! optional(red)가 아니다. ","date":"2022-09-27","objectID":"/operator/:6:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Range Operators (범위 연산자) ","date":"2022-09-27","objectID":"/operator/:7:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Closed Range Operator (닫힌 범위 연산자) 닫힌 범위 연산자(a…b)는 a에서 b까지 실행되는 범위를 정의하고 값 a와 b를 포함한다. 단 a의 값은 b보다 크지 않아야 한다. 닫힌 범위 연산자는 for-in 루프와 같이 모든 값을 사용하려는 범위를 반복할 때 유용한다. for index in 1...5 { print(\"\\(index) times 5 is \\(index * 5)\") } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 ","date":"2022-09-27","objectID":"/operator/:7:1","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Half-Open Range Operator (반 열린 범위 연산자) 반 열린 범위 연산자(a..\u003cb)는 a에서 b까지 실행되지만 b를 포함하지 않는 범위를 정의한다. 닫힌 범위 연산자와 마찬가지로, a의 값은 b보다 크지 않아야 한다. 첫 번째 값을 포함하지만 최종 값은 포함하지 않기 때문에 반쯤 열려 있다고 한다. let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] let count = names.count for i in 0..\u003ccount { print(\"Person \\(i + 1) is called \\(names[i])\") } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack ","date":"2022-09-27","objectID":"/operator/:7:2","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"One-Sided Ranges (단방향 범위) 아래와 같은 형태로 범위의 시작 혹은 끝만 지정해 사용하는 범위 연산자이다. 지정한 시작 값 혹은 끝 값은 범위에 포함된다. let names = [\"A\", \"B\", \"C\", \"D\"] for name in names[2...] { //[...2], [..\u003c2] 와 같이도 사용가능 하다. print(name) } // C // D ","date":"2022-09-27","objectID":"/operator/:7:3","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Logical Operators (논리 연산자) ","date":"2022-09-27","objectID":"/operator/:8:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"NOT Operator (!) 불리언 값 또는 표현식의 결과를 현재와 반대로 바꿈 let flag = true // 변수는 참 let secondFlag = !flag // secondFlag는 거짓으로 설정됨 ","date":"2022-09-27","objectID":"/operator/:8:1","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"AND Operator (\u0026\u0026) 논리 AND 연산자(a \u0026\u0026 b)는 전체 표현식이 참이 되려면 두 값이 모두 참이어야 하는 논리 표현식을 만든다. let id : Bool let password : Bool if id \u0026\u0026 password { print(\"Login success\") } else { print(\"Login failed\") } // id = true, password = true 일 경우 Login success // id = true, password = false 일 경우 Login failed // id = false, password = true 일 경우 Login failed // id = false, password = false 일 경우 Login failed 첫번 쨰 값이 false 면, 표현식이 true 가 될 수 없기에 두번째 값은 생략될 것이다. 이 것을 short-circuit evaluation 이라고 한다. ","date":"2022-09-27","objectID":"/operator/:8:2","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"OR Operator (||) 논리 OR 연산자(a || b)는 전체 표현식이 참이 되려면 두 값 중 하나만 true여야 하는 논리 표현식을 만드는 데 사용합니다. let id : Bool let password : Bool if id || password { print(\"Login success\") } else { print(\"Login failed\") } // id = true, password = true 일 경우 Login success // id = true, password = false 일 경우 Login success // id = false, password = true 일 경우 Login success // id = false, password = false 일 경우 Login failed ","date":"2022-09-27","objectID":"/operator/:8:3","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Combining Logical Operators (논리 연산자의 결합) 두 개 이상의 논리 연산자를 결합해 사용할 수 있다. 왼쪽의 표현이 우선순위가 높아 먼저 계산된다. if enteredDoorCode \u0026\u0026 passedRetinaScan || hasDoorKey || knowsOverridePassword { print(\"Welcome!\") } else { print(\"ACCESS DENIED\") } // Prints \"Welcome!\" ","date":"2022-09-27","objectID":"/operator/:8:4","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Explicit Parentheses (명시적 괄호) 논리 연산자의 적용 우선 순위를 연산자에 맡지기 않고 명시적으로 괄호를 사용해 계산 순서를 지정할 수 있다. if (enteredDoorCode \u0026\u0026 passedRetinaScan) || hasDoorKey || knowsOverridePassword { print(\"Welcome!\") } else { print(\"ACCESS DENIED\") } // Prints \"Welcome!\" 아니 저도 아무것도 모르는데 저 어캄? 저 암것도 모름 ","date":"2022-09-27","objectID":"/operator/:8:5","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"참고자료 Smile Han - iOS 1주차-8 : Swift 연산자 The Swift Programming Language - Basic Operators Apple Developer Documentation - Operator Declarations ","date":"2022-09-27","objectID":"/operator/:9:0","tags":["Swift"],"title":"[Swift] Operator(연산자)","uri":"/operator/"},{"categories":["Swift 문법"],"content":"Swift's Any, AnyObject","date":"2022-09-27","objectID":"/anyandanyobject/","tags":["Swift"],"title":"[Swift] Any \u0026 AnyObject","uri":"/anyandanyobject/"},{"categories":["Swift 문법"],"content":"AnyObject(protocal) AnyObject can represent an instance of any class type. AnyObject는 범용 타입이고 상속관계가 아니라도 타입 캐스팅 가능한 타입이다. 어떤 클래스의 객체도 저장 가능하다. 가장 추상화된 최상위 개념이고 Objective-C의 id와 같다. 클래스만 허용하며 구조체나 열거형은 허용하지 않는다. var x : Any = \"Hi\" print(x, type(of:x)) // Hi String x = 10 print(x, type(of:x)) // 10 Int x = 3.5 print(x, type(of:x)) // 3.5 Double //type을 검사해서 사용 ","date":"2022-09-27","objectID":"/anyandanyobject/:1:0","tags":["Swift"],"title":"[Swift] Any \u0026 AnyObject","uri":"/anyandanyobject/"},{"categories":["Swift 문법"],"content":"Any Any can represent an instance of any type at all, including function types. 클래스, 구조체, 열거형, 함수타입도 타입 캐스팅이 가능하다. (AnyObject와 차이점) ","date":"2022-09-27","objectID":"/anyandanyobject/:2:0","tags":["Swift"],"title":"[Swift] Any \u0026 AnyObject","uri":"/anyandanyobject/"},{"categories":["Swift 문법"],"content":"참고자료 Smaile Han - iOS 1주차-7 : Swift문법 Any, AnyObject ","date":"2022-09-27","objectID":"/anyandanyobject/:3:0","tags":["Swift"],"title":"[Swift] Any \u0026 AnyObject","uri":"/anyandanyobject/"},{"categories":["Swift 문법"],"content":"Swift's Optionals, Optional Binding, Forced Unwrapping,  Implicitly Unwrapped Optionals","date":"2022-09-27","objectID":"/optinals/","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Optional (옵셔널) 값을 반환할 때 오류가 발생할 가능성이 있는 값은 옵셔널 타입이라는 객체로 감싸서 반환한다. print(Int(\"123\")) // Optional(123) 을 출력 print(Int(\"Hi\")) // Int(\"Hi\") 은 정수 값을 반환할 수 없음, 아무런 값도 반환할 수 없다는 의미로 nil을 반환 ","date":"2022-09-27","objectID":"/optinals/:1:0","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Optional Type (옵셔널 타입) Swift에서는 기본 자료형(Int, Double, String 등)은 기본적으로는 nil값을 저장할 수 없지만 옵셔널 타입을 이용하여 nil 값을 저장할 수 있다. 옵셔널 타입은 변수 또는 상수에 아무런 값이 할당되지 않는 상황을 안전하게 처리하기 위한 방법 제공한다. 옵셔널 타입 변수를 선언하기 위해서는 타입 선언부 뒤에 “?” 문자를 쓴다. let num : Int? num = 10 print(num) // Optional(10) 중요 : 데이터 타입 뒤에 “?” 가 온다. ","date":"2022-09-27","objectID":"/optinals/:1:1","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Optional Forced Unwrapping (옵셔널 강제 언래핑) 옵셔널 변수에 값이 있으면 옵셔널로 “래핑되었다(wrapped)“고 한다. 옵셔널에 래핑된 값은 강제 언래핑(forced unwrapping)으로 풀어준다. var x : Int? x = 10 print(x) // Optional(10) print(x!) // 10 // 옵셔널형 선언 : 자료형 뒤 ? // 옵셔널 언래핑 : 변수명 뒤 ! ","date":"2022-09-27","objectID":"/optinals/:1:2","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Optional Binding (옵셔널 바인딩) 옵셔널에 할당된 값을 임시 변수 또는 상수에 할당하여 사용하는 방법이다. if let constantName = someOptional { statements } // 기본 사용법 var pet1: String? var pet2: String? pet1 = \"cat\" pet2 = \"dog\" if let firstPet = pet1, let secondPet = pet2 { print(firstPet, secondPet) // cat dog } else { print(\"nil\") } // pet1, pet2 가 nil 이 아닐 때 if 실행, nil일 경우 else 실행 Swift 5.7 버전 이후로 Optional Binding을 다음과 같이 작성할 수 있다. var pet1: String? var pet2: String? pet1 = \"cat\" pet2 = \"dog\" if let pet1, let pet2 { // Swift 5.7 버전 이후 지원 print(pet1, pet2) // cat dog } else { print(\"nil\") } ","date":"2022-09-27","objectID":"/optinals/:2:0","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Implicitly Unwrapped Optionals (암묵적 언래핑) 옵셔널이 항상 유효한 값을 가질 경우 옵셔널이 암묵적인 언래핑(implicitly unwrapped)이 되도록 선언할 수 있다. 암묵적인 언래핑 방법으로 옵셔널이 선언된다면 강제 언래핑이나 옵셔널 바인딩을 하지 않아도 값에 접근할 수 있다. 클래스의 아웃렛 변수 초기화에서 많이 사용된다. (자동 생성되는 코드) 암묵적인 언래핑으로 옵셔널을 선언하기 위해서는 선언부에 물음표(?) 대신에 느낌표(!)를 사용한다. let x : Int? = 1 let y : Int = x! let z = x print(x,y,z) //Optional(1) 1 Optional(1) print(type(of:x),type(of:y),type(of:z)) //Optional\u003cInt\u003e Int Optional\u003cInt\u003e ","date":"2022-09-27","objectID":"/optinals/:3:0","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"참고자료 Smile Han - iOS 1주차-5 : optional 변수, forced unwrapping, optional binding, nil Smile Han - iOS 1주차 5-1 : implicitly unwrapped optional The Swift Programming Language ","date":"2022-09-27","objectID":"/optinals/:4:0","tags":["Swift"],"title":"[Swift] Optinal(옵셔널), Optional Binding(옵셔널 바인딩)","uri":"/optinals/"},{"categories":["Swift 문법"],"content":"Swift's tuple","date":"2022-09-25","objectID":"/tuple/","tags":["Swift"],"title":"[Swift] Tuple","uri":"/tuple/"},{"categories":["Swift 문법"],"content":"Tuple(튜플) 튜플은 Swift 에서 가장 강력한 기능 중 하나이다. 여러 값을 하나의 개체에 일시적으로 묶는 방법이다. 튜플에는 타입과 상관없이 요소들을 저장할 수 있고, 저장된 값들이 모두 동일한 타입이어야 한다는 제약이 없다. 튜플의 요소들은 다양한 방법들을 이용해 접근할 수 있다. 인덱스 위치를 참조하여 접근할 수 있다. let myTuple = (10, 12.1, \"Hi\") let myString = myTuple.2 print(myString) //Hi 튜플의 요소를 추출하여 번수 또는 상수에 할당하여 사용할 수 있다. let myTuple = (10, 12.1, \"Hi\") let (myInt, myFloat, myString) = myTuple let (myInt2, _, myString2) = myTuple //튜플의 값을 선택적으로 추출할 수 있고, 무시하고 싶은 값에 밑줄을 사용하면 된다. 튜플을 생성할 때 각 값에 이름을 할당하여 사용할 수 있다. let myTuple = (count: 10, length: 12.1, message: \"Hi\") //튜플에 저장된 값에 할당된 이름은 각 값을 참조하는데 사용된다. print(myTuple.message) //Hi 튜플의 가장 강력한 점은 함수에서 여러 값들을 한번에 반환하는 것이다. ","date":"2022-09-25","objectID":"/tuple/:1:0","tags":["Swift"],"title":"[Swift] Tuple","uri":"/tuple/"},{"categories":["Swift 문법"],"content":"참고자료 Smile Han Youtube - iOS 1주차-4 : Swift Tuple ZeddiOS - Swift)tuple ","date":"2022-09-25","objectID":"/tuple/:2:0","tags":["Swift"],"title":"[Swift] Tuple","uri":"/tuple/"},{"categories":["Blog"],"content":"utterance를 이용한 블로그 댓글 기능 추가","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"utterance를 사용한 이유 댓글 기능을 구현할 수 있는 여러 종류(disqus, gittalk, giscus 등)의 댓글 플랫폼들이 있지만, 많은 플랫폼 중에 utterances를 선택한 이유는 다음과 같다. utterances는 Github 계정 로그인을 통해 댓글을 달고, 댓글이 달리면 알림이 Github Repository 의 Issue 로 올라오는 시스템이여서 댓글이 달리면 메일로 댓글 알림을 받을 수 있다. 그리고 광고가 없고 가볍다. 마지막으로, 마크다운 문법을 사용할 수 있다. ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:1:0","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"utterances 적용하기 ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:2:0","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"1. Issue(댓글)이 저장될 Repository를 정하거나 생성한다. 나는 기존 블로그용으로 사용하는 GangsangMSK.github.io Repository를 정했다. ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:2:1","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"2. utterance를 설치하기 https://github.com/apps/utterances 링크를 통해 설치할 수 있다. 설치를 할 때, 전체 Repository의 Issue 들에 업로드가 되게 할지, 아니면 특정한 저장소의 Issue 에만 업로드가 되게 할지 선택할 수 있다. 사진과 같이 Only select reposioires를 통해, Issue(댓글)가 올라올 Repository를 위에서 선택한 후 Install 하면 된다. ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:2:2","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"3. Install 후 페이지 작성 https://utteranc.es 에 접속하여 다음과 같은 페이지를 작성한다. repo 위에서 Issue가 올라올 곳으로 선택한 Repositoty 를 써준다. (github아이디/저장소이름) ex) GangsangMSK/GangsangMSK.github.io ex) GangsagnMSK/blog-comments Blog Post \u003c-\u003e Issue Mapping Issue가 달린 블로그 페이지의 어떤 부분과 매핑을 시킬지 Key 값을 결정한다. 매핑시키는 것이니만큼 Key 값이 달라지면 Value 갑은 사라질 것이다. 수정을 하지 않는 pathname을 선택한다. ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:2:3","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"4. 블로그에 적용하기 페이지 작성 시, 위와 같이 스크립트를 자동으로 생성해준다. 이를 복사하거나 참고하여 블로그에 적용시켜준다. 내가 쓰는 Hugo의 LoveIt 테마 같은 경우 위와 같이 적용시켜준다. 그러면 이렇게 Github의 Issue 기능을 사용하는 utterance로 블로그 댓글 기능이 추가된다. ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:2:4","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Blog"],"content":"참고자료 [Github 블로그] utterances 으로 댓글 기능 만들기 (+ disqus 비추후기) ","date":"2022-09-21","objectID":"/makeblogcommentswithutterance/:3:0","tags":["Blog"],"title":"[Blog] utterance를 이용한 블로그 댓글 기능 만들기","uri":"/makeblogcommentswithutterance/"},{"categories":["Swift 실습"],"content":"Swift Practice","date":"2022-09-20","objectID":"/220920/","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Simple Values import UIKit var greeting = \"Hello, playground\" var x = 10 print(x) //10 ","date":"2022-09-20","objectID":"/220920/:1:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Control Flow(제어 흐름) ","date":"2022-09-20","objectID":"/220920/:2:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Functions and Closures(함수와 클로져) ","date":"2022-09-20","objectID":"/220920/:3:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Objects and Classes(객체와 클래스) ","date":"2022-09-20","objectID":"/220920/:4:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Enumerations and Structures(열거형과 구조체) ","date":"2022-09-20","objectID":"/220920/:5:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Concurrency(동시성) ","date":"2022-09-20","objectID":"/220920/:6:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Protocols and Extensions(프로토콜과 확장) ","date":"2022-09-20","objectID":"/220920/:7:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Error Handling (오류 처리) ","date":"2022-09-20","objectID":"/220920/:8:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Generics ","date":"2022-09-20","objectID":"/220920/:9:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 실습"],"content":"Style Guide Swift 스타일 가이드 Swift 공식 문서 ","date":"2022-09-20","objectID":"/220920/:10:0","tags":["Swift Practice"],"title":"[Swift Practice] in 22/09/20","uri":"/220920/"},{"categories":["Swift 문법"],"content":"Swift's type annotation and type inference","date":"2022-09-19","objectID":"/type_annotationtype_inference/","tags":["Swift"],"title":"[Swift] 타입 어노테이션(Type annotation)과 타입 추론(Type inference)","uri":"/type_annotationtype_inference/"},{"categories":["Swift 문법"],"content":"Swift는 타입 안전(Type safe) 프로그래밍 언어이다. 그로 인해 변수의 타입이 식별되면, 그 변수는 다른 타입의 데이터를 저장하는데 사용할 수 없다. 변수가 선언되 후에도 다른 타입의 데이터를 저장할 수 있는 loosely typed(Ex:JavaScript) 언어와 대조적이다. 변수 또는 상수의 식별 방법엔 두 가지가 존재한다. 타입 어노테이션(Type annotation) 변수 또는 상수가 코드 내에서 선언되는 시점에 데이터 타입을 정해주는 경우 변수 또는 상수 이름 다음에 타입 선언을 하면 된다. var num : Int = 10 // : Int가 Type annotation 상수를 선언할 때도 타입 어노테이션을 통해 나중에 값을 할당할 수 있다. let bookTitle : String var book = true if book { bookTitle = \"iOS\" } else { bookTitle = \"Android\" } print(bookTitle) // 값이 한번만 할당되어 사용가능 //iOS 타입 추론(Type inference) 선언부에 타입 어노테이션이 없어, 컴파일러가 데이터 타입 식별을 위해 변수 또는 상수에 값이 할당되는 시점에 값의 타입을 확인하여 정해주는 경우 var num = 10 // 10(Int)를 통해 num이라는 변수의 타입을 Int라 추론 // var num : Int = 10 ","date":"2022-09-19","objectID":"/type_annotationtype_inference/:0:0","tags":["Swift"],"title":"[Swift] 타입 어노테이션(Type annotation)과 타입 추론(Type inference)","uri":"/type_annotationtype_inference/"},{"categories":["Swift 문법"],"content":"Swift's var \u0026 let","date":"2022-09-19","objectID":"/varlet/","tags":["Swift"],"title":"[Swift] var과 let","uri":"/varlet/"},{"categories":["Swift 문법"],"content":"var / 변수 변수는 프로그램에서 사용될 데이터를 저장하기 위한 메모리 공간이다. 변수는 할당된 값의 변경이 가능하다. var 변수명 : 데이터 타입 // 사용법 var x = 0.0, y= 0.0, z = 0.0 // ,를 사용하여 여러개의 변수 선언 가능 var num = 10 // : Int 생략가능 num = 20 //문제 없음 ","date":"2022-09-19","objectID":"/varlet/:1:0","tags":["Swift"],"title":"[Swift] var과 let","uri":"/varlet/"},{"categories":["Swift 문법"],"content":"let / 상수 상수(const)는 데이터 값을 저장하기 위한 메모리 공간을 제공하는 점은 변수와 비슷하나, 한번 할당되면 그 이후로는 값을 변경할 수 없다. 상수는 코드 내에서 반복적으로 사용하는 값이 있을 경우, 상수에 할당하여 사용하면 유지보수에 도움이 된다. let 상수명 : 데이터 타입 let test : String //선언 시, 초기화를 안해주어도 사용가능함 let text : String = \"상수\" text = \"변수\" //syntax error 발생 애플은 코드의 효율성과 실행 성능을 높이기 위해서 변수(var)보다는 상수(let) 사용을 권장한다. ","date":"2022-09-19","objectID":"/varlet/:2:0","tags":["Swift"],"title":"[Swift] var과 let","uri":"/varlet/"},{"categories":["Swift 문법"],"content":"참고자료 Swift Language Guide Smile Han Youtube - iOS 1주차-3 : Swift 데이터타입, var, let 다소니닷넷:티스토리 ","date":"2022-09-19","objectID":"/varlet/:3:0","tags":["Swift"],"title":"[Swift] var과 let","uri":"/varlet/"},{"categories":null,"content":"iOS 앱 개발자를 목표로 공부하고 있습니다. ","date":"2022-09-19","objectID":"/about/introduce/:0:0","tags":null,"title":"Introduce","uri":"/about/introduce/"},{"categories":["Swift 문법"],"content":"Swift's datatype","date":"2022-09-16","objectID":"/datatype/","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"자료형(Data Type)의 종류 ","date":"2022-09-16","objectID":"/datatype/:1:0","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"Int Integer는 42와 -23과 같은 소수점이 없는 정수이다. 정수는 부호(양수, 0 또는 음수) 또는 부호가 없는(양수 또는 0)이다. Swift는 8, 16, 32 및 64비트 형태로 Unsigned Integer를 지원한다. 이 Integer는 C와 유사한 명명 규칙을 따르며, 8비트 Unsigned Integer는 UInt8 유형이고 32비트 부호 있는 정수는 Int32 유형이다. Swift의 모든 유형과 마찬가지로, 이러한 Integer 유형에는 대문자를 사용한다. 하지만 애플은 특정 크기의 데이터 타입보다는 Int 데이터 타입 사용을 권장한다. Int 데이터 타입은 해당 코드가 실행되는 플랫폼에 맞는 정수 크기를 사용한다. var [변수명] : Int = [초깃값] //초깃값 입력 시, Int 생략 가능 print(Int32.min) //최솟값 //-2147483648 print(Int32.max) //최댓값 //2147483647 해당하는 자료형의 .min, .max를 이용하면 최솟값과 최대값을 구할 수 있다. ","date":"2022-09-16","objectID":"/datatype/:1:1","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"Float \u0026 Double 소수는 3.14159, 0.1 및 -273.15와 같은 소수점을 가진 숫자이다. Float와 Double 데이터 타입은 Int 데이터 타입보다 훨씬 더 넓은 범위의 값을 나타내고 저장할 수 있습니다. Float 데이터 타입은 32비트로 부동 소수점 수를 저장하고, 소수점 6자리까지 정확도를 가집니다. Double 데이터 타비은 64비트로 부동 소수점 수를 저장하고, 소수점 15자리까지 정확도를 가집니다. 소수를 표현하는 데이터 타입은 Double이 기본이다. var [변수명] : Float = [초깃값] //초깃값 입력 시, Float 생략 가능 var [변수명] : Double = [초깃값] //초깃값 입력 시, Double 생략 가능 ","date":"2022-09-16","objectID":"/datatype/:1:2","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"Bool 참 또는 거짓(1 또는 0) 조건을 처리하는 데이터 타입이다. Boolean 데이터 타입을 처리하기 위하여 두개의 Boolean 상수 값(true/false)을 사용한다 var [변수명] : Bool = [true/false] //초깃값 입력 시, Bool 생략 가능 ","date":"2022-09-16","objectID":"/datatype/:1:3","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"Character 문자, 숫자, 문장 부호, 심볼 같은 유니코드(Unicode) 문자 하나를 저장한다. Swift에서의 문자들은 문자소 묶음(grapheme cluster)의 형태로 저장한다. 문자소 묶음은 하나의 문자를 표현하기 위하여 유니코드 코드 값들로 이루어진다. var [변수명] : Character = [초깃값] //Character 생략불가, 생략 시 String 데이터 타입이 된다. ","date":"2022-09-16","objectID":"/datatype/:1:4","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"String 단어나 문장을 구성하는 일련의 문자다. 저장, 검색, 비교, 문자열 연결, 수정 등의 기능을 포함한다. 문자열 보간(string interpolation)을 사용하여 문자열과 변수, 상수, 표현식, 함수 호출의 조합으로 만들 수도 있다. var [변수명] : String = [초기값] //String 생략하여 사용하는 것이 일반적임 문자열 보간법(string interpolation) 문자열 보간법(String Interpolation)은 변수 또는 상수 등의 값을 문자열 내에 나타내고 싶을 때 사용하는데 문자열 내에 (변수나 상수) 의 형태로 표기하면 이를 문자열로 치환해서 넣어 준다. 문자열 보간법을 이용해 프로그래머가 원하는 문자열로 치환하려면 변수나 상수 타입을 CustomStringConvertible프로토콜을 준수하는 description프로퍼티로 구현한다. ","date":"2022-09-16","objectID":"/datatype/:1:5","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Swift 문법"],"content":"참고자료 Swift Language Guide Smile Han Youtube - iOS 1주차-3 : Swift 데이터타입, var, let Mr.후:티스토리 ","date":"2022-09-16","objectID":"/datatype/:2:0","tags":["Swift"],"title":"[Swift] DataType(자료형)","uri":"/datatype/"},{"categories":["Blog"],"content":"hugo, Github, Mac을 이용하여 github.io를 생성하는 방법","date":"2022-09-13","objectID":"/makeblogwithhugoandgithub/","tags":["Mac","Linux","OS","Blog"],"title":"[Blog] hugo \u0026 Github을 사용한 블로그 구축","uri":"/makeblogwithhugoandgithub/"},{"categories":["Blog"],"content":"개발환경 Hardware : Macbook Pro(16-inch,M1,2021) OS : macOS Monterey 12.5 Shell : zsh hugo : hugo v0.102.3+extended darwin/arm64 brew : Homebrew 3.6.1 ","date":"2022-09-13","objectID":"/makeblogwithhugoandgithub/:1:0","tags":["Mac","Linux","OS","Blog"],"title":"[Blog] hugo \u0026 Github을 사용한 블로그 구축","uri":"/makeblogwithhugoandgithub/"},{"categories":["Blog"],"content":"블로그 구축 방법 Github repository 생성 블로그 구축을 위해 소스 원본 저장 및 관리용 개발용(Development) repository : blog 개발용 repository를 빌드한 결과물 서비스용 repositoty : (username).github.io 2개의 repository를 생성한다. 2개의 repository 사용은 블로그를 운영하는 데에 필수는 아니지만, 일괄적으로 Github repository에서 글 작성, 변경이나 버전 관리 등이 편하기에 사용한다. Hugo 설치 Homebrew를 사용하여 hugo 설치 $ brew install hugo hugo가 설치되었는지 확인 $ brew version hugo v0.102.3+extended darwin/arm64 BuildDate=unknown 정상적으로 hugo가 설치되었으면 버전이 출력된다. 사이트 생성 프로젝트를 만들 폴더로 이동한다. $ pwd /Users/ms ## 트리 구조로 본 프로젝트 경로 / └── Users └── ms └── blog \u003c== 내가 새로 만들 블로그 폴더 사이트 생성 명령어 $ hugo new site [프로젝트 이름(폴더 명)] $ hugo new site blog Congratulations! Your new Hugo site is created in /Users/ms/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. 메세지와 함께 blog 폴더가 생성된 걸 확인할 수 있다. 테마 다운로드 현재 블로그 테마는 LoveIt을 사용하고 있다. 블로그 프로젝트 폴더로 이동하여 git init 명령어를 통해 git 환경을 구성한다. $ pwd /Users/ms/blog $ git init 서브모듈(submodule)의 개념 Git의 서브모듈(Submodule)이란 하나의 저장소(Repository) 안에 있는 또 다른 별개의 저장소이다. 보통 다른 원격 저장소를 가져와(Pull) 서브모듈로 사용하게 된다. 테마 깃허브 저장소를 서브모듈로 가져오기 $ pwd /Users/ms/blog $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt git submodule 명령어를 통해 submodule 목록이 생성된 걸 확인할 수 있다. $ git submodule e9e89a4613baee823596822b7d246f5931263491 themes/LoveIt (v0.2.11-143-ge9e89a4) 설정파일(config.toml) 생성 다음으로 themes/LoveIt/exampleSite/config.toml 파일을 복사해 초기에 생성된 config.toml 에 덮어쓴다. . ├── archetypes ├── config.toml \u003c== 초기에 생성된 config.toml [...] └── themes └── LoveIt └── exampleSite └── config.toml \u003c== 복사할 config.toml 교체된 config.toml 설정파일을 열어보면 themesDir 값을 삭제하고 저장한다. 게시글 생성 LoveIt 테마에서는 /content/posts/ 폴더 아래에 게시글이 생성되어야 정상적으로 출력된다. 테마마다 게시글이 위치해야하는 경로나 이름이 다를 수 있다. 테마 페이지에서 안내해주는 가이드 문서를 참고하여 게시글을 해당 경로에 맞게 생성해야 한다. Front Matter 설명 title : 게시글의 제목 date : 게시글의 최초 작성시간 lastmod : 게시글의 마지막 수정시간 description : 게시글의 설명. 검색엔진 최적화(SEO, Search Engine Optimization)를 위해서 게시글 제목(title)에 담긴 내용을 풀어 간단하게 적어놓는다. draft : draft: true 일 경우, 실제 배포환경에서 해당 게시글은 보이지 않게 된다. 작성한 글을 개발 환경이 아닌 실제 환경에도 게시하고 싶다면 반드시 draft: false 값을 설정한다. tags : 게시글의 태그 toc : table of content의 약자. Front Matter의 값이 toc: true 일 경우 마크다운 기반의 게시글 목차를 정리해서 보여준다. categories : 게시글의 목록 $ hugo new posts/FirstPost.md \u003c== 포스트 만들기 $ hugo serve \u003c== 로컬호스트 서버 실행하기 Start building sites … hugo v0.102.3+extended darwin/arm64 BuildDate=unknown WARN 2022/09/14 16:27:51 Current environment is \"development\". The \"comment system\", \"CDN\" and \"fingerprint\" will be disabled. 当前运行环境是 \"development\". \"评论系统\", \"CDN\" 和 \"fingerprint\" 不会启用. | EN -------------------+----- Pages | 19 Paginator pages | 0 Non-page files | 0 Static files | 75 Processed images | 0 Aliases | 6 Sitemaps | 1 Cleaned | 0 Built in 55 ms Watching for changes in /Users/ms/blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/ms/blog/config.toml, /Users/ms/blog/themes/LoveIt/config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 마지막에 Web Server is available at http://localhost:1313/ 메세지가 출력되면 정상적으로 완료된 것이다. 인터넷 브라우저를 열어 http://localhost:1313/ 으로 접속한다. 블로그가 제대로 실행되는지 확인한다 git remote 추가 명령어 형식 $ git remote add origin [개발용 repository의 URL] git remote : 현재 프로젝트에 등록된 리모트 저장소를 확인하는 명령어이고 리모트 저장소의 단축 이름을 보여준다. 레포지터리를 복제(Clone)하면 origin이라는 리모트 저장소가 자동으로 등록되기 때문에 origin이라는 이름을 볼 수 있다. origin : 축약형 이름을 말한다. 개발용(Development) repository의 URL : https://github.com/\u003cGithub 유저네임\u003e/\u003c블로그용 레포지터리 이름\u003e 리모트 저장소가 정상적으로 추가되었는지 git remote -v 명령어로 확인한다. -v 옵션을 주면 등록된 리모트 저장소의 이름과 URL을 같","date":"2022-09-13","objectID":"/makeblogwithhugoandgithub/:2:0","tags":["Mac","Linux","OS","Blog"],"title":"[Blog] hugo \u0026 Github을 사용한 블로그 구축","uri":"/makeblogwithhugoandgithub/"},{"categories":["Blog"],"content":"참고자료 Hugo-LoveIt 테마 구축 방법 Hugo x github 블로그 설치 방법 ","date":"2022-09-13","objectID":"/makeblogwithhugoandgithub/:3:0","tags":["Mac","Linux","OS","Blog"],"title":"[Blog] hugo \u0026 Github을 사용한 블로그 구축","uri":"/makeblogwithhugoandgithub/"}]